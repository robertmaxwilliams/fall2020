\documentclass[12pt,letterpaper]{article}
\usepackage{preamble}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{csvsimple}
\usepackage{booktabs}

\lstdefinelanguage{alg}{
morekeywords={def,if,then,else,while,do,assert,end}
}


\newcommand\course{CSE 625}
\newcommand\hwnumber{2}
\newcommand\userID{Max Williams}

\newcommand{\tf}[2]{\frac{\text{#1}}{\text{#2}}}

\newcommand{\problem}[1]{\textit{#1} \medskip}
\newcommand{\solution}{ \noindent \textbf{Solution:} \medskip}
\let\cc\lstinline

\begin{document}

\section{Problem 1}

\subsection{Problem 1.a}

My computer supports 4 concurrent threads. I used the following code example from cppreference.com:

\lstinputlisting{MNIST/concurrency.cpp}

And get the output:

\lstinline{4 concurrent threads are supported.}

\subsection{Problem 1.b}

Running both the \cc{push_back} and \cc{emplace_back} version using the following code:

\lstinputlisting{hello.cpp}

works correctly, printing the different hello's in a random and overlapping way, often with the
number and newline coming last. 

While the differences between the two can very depending on implementations (and in non-pathological
cases, they should exhibit the same behavior), the main practical difference is that \cc{push_back}
will use a copy constructor of objects passed into it, while \cc{emplace_back} will use the move
constuctor (which is generally cheaper).

\section{Problem 2}

\subsection{Problem 2.a}

MNIST exists to provide a stardard for benchmarking image classification models and other data
science applications. It provides a very large, high quality, and low resolution collection of
labeled images, perfect for quickly prototyping and testing image classifiers.

\subsection{Problem 2.b}

The training set has 60,000 images and the testing set has 10,000 images.

\end{document}
